# Контрольные вопросы
### Как организован механизм генерации случайных чисел в библиотеке random?
Механизм генерации случайных чисел делится на следующие этапы:
1. Получение начальной энтропии с помощью uniform_random_bit_generator (c++20) или любого другого функционального объекта, удовлетворяющего требованиям UniformRandomBitGenerator (c++11). В идеале, такой объект должен возвращать с равной вероятностью любое натуральное число из заданного диапазона и являться недетерменированным, как, например, std::random_device в некоторых реализациях.
2. Затем механизмы генерации случайных чисел генерируют псевдослучайные числа с помощью специального алгоритма, используя полученное ранее зерно в качестве источника энтропии. В библиотеке random есть три типа генератора псевдослучайных чисел отличающиеся скоростью работы, занимаемой в процессе генерации памятью и спектральными характеристиками:
	- linear_congruential_engine
	- mersenne_twister_engine
	- subtract_with_carry_engine
Кроме того, есть 3 адаптера механизма случайных чисел, использующих в качестве источника энтропии другой генератор и несколько конкретных готовых алгоритмов на основе одного из этих 6 генераторов.
3. Далее необходимо создать объект распределения случайных чисел и передать в него генератор. Объект распределения будет выдавать числа таким образом, что результирующие выходные данные распределятся в соответствии с определенной статистической функцией плотности вероятности.

### Чем отличаются функциональные объекты от функций и лямбда-выражений?
- Функциональный объект является экземпляром класса, в отличие от функций и лямбд. Таким образом, упрощается создание функциональных объектов с одинаковой сигнатурой.
- В отличие от функции, у функционального объекта может быть состояние (при условии, что использование static-переменных не является хорошей практикой).
- Использование функциональных объектов позволяет компилятору выполнять более эффективные оптимизации, в связи с чем код будет работать быстрее.

### Какими наборами возможностей обладают итераторы разных категорий?
- Итераторы вставки (back_inserter, front_inserter, inserter) позволяют алгоритмам вставлять значения в контейнеры, в отличие от обычных итераторов, которые работают только с уже существующим набором элементов.
- Потоковый итератор ввода (istream_iterator) позволяет работать с потоком ввода -- извлекать из него значения до встречи символа EOF (конца потока).
- Потоковый итератор вывода (ostream_iterator) позволяет работать с потомк вывода -- заполнять его значениями.

### Какая классификация предлагается для алгоритмов стандартной библиотеки?
- Не модифицирующие
- Модифицирующие
- Операции секционирования
- Сортирующие
- В отсортированном диапазоне: алгоритмы двоичного поиска, алгоритмы множеств (std::set) и др.
- Операции с кучей
- Поиск минимума/максимума
- Операции сравнения
- Операции перестановки
- Числовые операции
- Операции с неинициализированной памятью

### Почему алгоритмы стандартной библиотеки предпочительнее собственных?
Правильно выбранный алгоритм стандартной библиотеки позволит добиться наилучшей в условиях задачи производительности и точно будет работать правильно. В отличие от собственных решений, на написание которых, к тому же, приходится уделять дополнительное время при отсутствии гарантий правильной и оптимальной работы.
