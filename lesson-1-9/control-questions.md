## Контрольные вопросы к 9 заданию
### Какие существуют способы обработки различных ошибок?

**Обработка "на месте"**
- `if`-`then`-`else` -- для проверки пользовательского ввода
- Aварийное завершение работы программы:
    - 'abort' -- принудительное решение программы
    - 'exit' -- указывает на "нормальный" конец программы, хотя может использоваться и для обработки ошибок
    - 'terminate' -- когда механизм управления особыми ситуациями не смог найти обработчик для запущенной особой ситуации; когда механизм управления особыми ситуациями столкнулся с нарушенной структурой стека.
- `assert` -- проверка корректности выражений (как в python), применяется только при дебаге.

**Передача информации об ошибке**
- Механизм исключения(`try`-`catch`-`throw`)
- return (some_error() - возвращает уведомление об ошибке(код ошибки)/ static errno - хранит значение последней ошибки/
- boost(&/*error) - переменной по ссылке или указателю присваивает код ошибки)

### В чем заключаются недостатки механизма кодов возврата?

1. Трудно обработать возвращаемое функцией значение, так как это может быть код возврата или непосредственно результат работы функции. Принято использовать совместно с union или `std::variant`
2. Мы не можем контролировать время жизни статической переменной внутри функции
3. Использование ссылок и указателей сильно усложняет код
4. Не получится использовать в конструкторах или перегрузке операторов
5. Такой код сложно расширять и поддерживать

### Какими особенностями обладает механизм исключений?

1. Многоуровневость -- f()->g()->h()
2. Побочные расходы (если нет исключений, то нет побочных расходов), т.к. сама ошибка генерируется только когда находится исключение
3. Преобразование -- переход от произвольного класса к базовому (можно создавать пользовательские классы ошибок)

### Для чего используется спецификатор и оператор `noexcept`?

1. Указывает компилятору что данная функция не выбрасывает исключений, что улучшает оптимизацию (компилятору не нужно беспокоиться о сохранении стека времени выполнения)
2. Однако он не запрещает функции выбрасывать исключения или вызывать другие функции, которые выбрасывают исключения
3. `noexcept(true)` равносильно `noexcept`, что означает, что функция не является выбрасывающей; `noexcept(false)` означает, что функция относится к классу потенциально выбрасывающих исключения функций
4. Использовать спецификатор noexcept стоит лишь в конкретных случаях, когда вы хотите явно указать на гарантию отсутствия сбоя или отсутствие выбрасывания исключения (геттеры, операторы копирования, конструктор копирования и все специальные функции-члены сгенерированные по умолчанию)

Оператор проверяет переданное выражение на то, является ли оно `noexcept`.

### Как формулируются гарантии безопасности исключений?

1. Базовая гарантия -- нет нарушения инвариантов и утечек ресурсов (идиома RAII)
2. Строгая гарантия -- транзакционное поведение, то есть если при выполнении операции возникнет исключение, то программа останется в том же состоянии, которое было до начала выполнения операции
3. Гарантия отсутствия исключений/сбоев -- исключения не генерируются
