## Контрольные вопросы к седьмому семинару
***
### Перечислите все специальные функции-члены класса, включая перемещающие операции.
- Конструктор по-умолчанию;
- Пользовательские кострукторы;
- Деструктор;
- Операторы;
- Копирующий конструктор;
- Перемещающий конструктор.

### Приведите примеры операторов, которые можно, нельзя и не рекомендуется перегружать.
`->`, `[]`, `()` -- можно перегружать;

`&`, `,` -- не рекомендуется;

`::`, `.`, `.*` -- нельзя перегружать

### О каких преобразованиях следует помнить при проектировании операторов?
Следует помнить о неявных пользовательских преобразованиях, то есть в классе должен быть **не**-`explicit` конструктор, который выполнял бы неявное преобразование к, например, целочисленному типу:
```cpp
X var(1.3);
1 + var; // при отсутствии нужного конструктора будет ошибка
```

### Опишите классификацию выражений на основе перемещаемости и идентифицируемости.

<img src="figures/expressions.png" alt="expression types" width="300"/>

Обладают свойствами:
- **glvalue** -- индентифицируемости
- **rvalue** -- перемещаемости

Соответственно:
- **xvalue** -- (от англ. eXpiring) обладает свойствами индентифицируемости и перемещаемости
- **lvalue** -- индентифицируемости, но не перемещаемости
- **prvalue** -- перемещаемости, но не индентифицируемости

### Зачем нужны rvalue-ссылки (`&&`)?

rvalue-ссылка позволяет нам быть использованной в rvalue-выражениях:
```cpp
T& var = T(12);   // ERROR: lvalue-ссылка не может использоваться в rvalue-выражениях
T&& var = T(12);            // OK
T&& var = std::move(var_);  // OK
```

### Почему семантика перемещения лучше копирования?
Потому что это при правильном использовании семантика перемещения позволяет расходовать меньше вычислительных ресурсов и памяти, чем семантика копирования.

### Что делает функия `std::move` и когда нет необходимости явно ее вызывать?
`std::move(T x)` приводит аргумент к rvalue-ссылке.

### Кем выполняется непосредственная работа по перемещению?
move-конструктором.

### Когда может потребоваться пользовательская реализация специальных функций-членов класса?
- Для расширения функционала класса, например: реализация операторов, неявное преобразование других классов к нашему и наоборот;
- При проектировании класса, которые будет динамически взаимодействовать с памятью, следует реализовать деструктор, который будет корректно освобождать используемые участки памяти;
- Реализация семантики перемещения или копирования -- для этого можно создать свой копирующий или перемещающий конструктор.

### Для чего нужны ключевые слова `default` и `delete` в объявлении специальных функций-членов класса?
