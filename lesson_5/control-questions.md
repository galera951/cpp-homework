# Контрольные вопросы к пятому заданию

### Какими способами можно задать значения для данных-членов структуры?

Существует несколько способов задания данных-членов структур:
- Присваивание значений после создания экземпляра структуры: `Student ivan; ivan.name = "Ivan";`
- Использование значений по умолчанию непосредственно в теле структуры: `struct Student {std::string name("Ivan");};`
- Использование универсальной или агрегатной инициализации: `Student ivan{"Ivan"};`
- Использование конструктора для инициализации полей:
```cpp
struct Student {
  Student(std::string name): _name(name) {  }

  std::string _name;
};
```

### Для чего предназначены списки инициализации в конструкторах структур?

Только с помощью списка инициализации можно инициализировать константу и ссылку, также принято их использовать для инициализации полей при передаче значений при создании экземпляра структуры.

### Как идиома RAII реализовывается с помощью конструктора и деструктора?

RAII -- это программная идиома, смысл которой заключается в том, что получение некоторого ресурса связано с инициализацией, а освобождение -- с уничтожением объекта. Эту идиому достаточно легко реализовать с помощью конструктора и деструктора, ведь каждый раз при инициализации объекта вызывается его конструктор, а при уничтожении (уход из поля видимости) -- деструктор.

### Когда стоит рассматривать использование битовых полей и объединений (union)?

Использование битовых полей и объединений следует рассматривать в том случае, если нам очень важна оптимизация памяти, которую занимает программа в процессе работы, например, в микроконтроллерах. В персональных компьютерах и других устройствах с огромным запасом памяти их использование излишне.

### Какими особенностями обладают перечисления с областью видимости?

Перечисления с областью видимости (`enum class Months {};`) обладают следующими особенностями:
- Доступ к переменным перечисления осуществляются с помощью оператора разрешения области видимости (`::`): `Months::january`
- Переменные перечислений с областью видимости не могут неявно преобразовываться в целочисленные переменные и обратно. Необходимо использование `int red = static_cast<Colors>(Colors::red);`
