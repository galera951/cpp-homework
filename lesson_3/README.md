# Третий семинар

## Низкий уровень абстрации ("голый" C++)
### Указатели

`T *ptr` или лучше `int* ptr`, где T -- тип: указатель на T

```cpp
char c = 'a';
char* ptr;

ptr = &c; // & -- оператор взятия адреса

*ptr = `b`;
```

```cpp
ptr = nullptr; // занулить указатель (для безопасности), это нужно регулярно проверять
```

**Управление памятью**

`malloc(size_t n) -> void*`
возвращает указатель на `void` (не разыменовывается), далее можно преобразовать с помощью `static_cast`.

Для освобождения участка памяти `free(ptr)`, чтобы предотвратить утечки.

Примеры:
```cpp
#include <iostream>

int main() {
  const short AMOUNT_INT = 5;

  int* ptr = static_cast<int*>(malloc(sizeof(int) * AMOUNT_INT));

  for (int* i = ptr; i < ptr + AMOUNT_INT; i++) {
    *i = 1;
  };

  for (int* i = ptr; i < ptr + AMOUNT_INT; i++) {
    std::cout << *i << '\n';
  };

  free(ptr);
}
```

### Массивы

#### Статические массивы

`T a[size_t SIZE]`, SIZE - константа на момент компиляции!

`std::size(a)` -- размер массива (количество эл-тов)

При объявлении массива из тривиальных типов он заполняется мусором, иначе (другие типы) вызывается конструктор по умолчанию.

**Инициализация массива**

`int v1[6] = {1, 2, 3, 4, 5}` остальное заполнится нулями (агрегатная инициализация). Еще существует инициализация списком инициализации (пока *unknown*)

`int v1[6] = {}` будут только нули

`int v2[]{1, 2, 3, 4}` -- универсальная инициализация.

### Оператор `new`

### Ссылки (`rvalue` и `lvalue`)


## Высокий уровень абстрации (STD)
### Smart pointers

### Контейнеры (std::vector)
