#include <iostream>
#include <string>
#include <vector> // Эта библиотека нужна для использования векторов

int main()
{
    // При создании вектора небходимо в угловых скобках указать тип его элементов.
    // Вектор типа double на 10 элементов, проинициализированных значением 0.0:
    std::vector < double > v_1(10, 0.0);
    // Вектор типа int, проинициализированный пятью элементами:
    std::vector < int > v_2 = { 7, -42, 5, 0, 16, -8 };
    //Вектор строкового типа из трёх элементов.
    std::vector < std::string > v_3 = { "Red", "Green", "Blue" };

    // Выведем на экран элементы вектора. Можно использовать оператор[] для доступа по индексу.
    // Узнать число элементов вектора можно при помощи функции-члена size():
    for (auto i = 0U; i < v_1.size(); ++i)
    {
        std::cout << v_1[i] << ' ';
    }

    std::cout << std::endl;

    // Другой способ обойти элементы вектора без их изменения - использовать range-based for:
    for (auto x : v_3)
    {
        std::cout << x << ' ';
    }
    std::cout << std::endl;
    // Этот цикл проходит по контейнеру v_3, присваивая очередной его элемент переменной x.
    // Чтобы избежать лишнего копирования, можно использовать константную ссылку:
    //   for (const auto & x: v_3)

    // Если мы хотим, чтобы изменение x изменяло сам элемент вектора, используем ссылочный тип. Вот так все элементы v_2 возведутся в квадрат:
    for (auto& x : v_2)
    {
        x *= x;
    }

    for (const auto& x : v_2)
    {
        std::cout << x << ' ';
    }

    std::cout << std::endl;

    // Узнаем первый элемент вектора:
    std::cout << "v_2.front(): " << v_2.front() << std::endl;
    // Узнаем последний элемент вектора:
    std::cout << "v_2.back(): " << v_2.back() << std::endl;
    // Узнаем, пуст ли вектор:
    std::cout << "v_2.empty(): " << std::boolalpha << v_2.empty() << std::endl;

    std::cout << std::endl;

    // Вектор - динамический массив, он умеет увеличиваться, добавляя к себе в конец новые элементы:
    v_3.push_back("Yellow");
    std::cout << "v_3.back() after pushing back \"Yellow\": " << v_3.back() << std::endl;
    // Удаляется последний элемент вектора при помощи функции-члена pop_back():
    v_3.pop_back();
    std::cout << "v_3.back() after pop_back(): " << v_3.back() << std::endl;

    std::cout << std::endl;

    // Все элементы вектора удаляются с помощью функции-члена сlear()

    /******************************************************************************************\
    * Несколько слов от ИТЕРАТОРАХ (ITERATORS)
    *
    * Итератор для контейнеров является аналогом указателя для массивов -
    * это сущность, которая может указывать на определённый элемент контейнера.
    * К итераторам применим оператор разыменования * и арифметика указателей: +, -, ++ и тд..
    *
    * Вот так получается итератор на первый элемент вектора:
    *   auto iterator = v_1.begin(v_1);
    * Альтернативный (более новый) способ:
    *   auto iterator = std::begin(v_1);
    *
    * Вот так получается итератор на фиктивный элемент вектора, следующий за последним:
    *   auto iterator = v_1.end(v_1);
    * Альтернативный (более новый) способ:
    *   auto iterator = std::end(v_1);
    *
    * Очень удобно работать с полуоткрытым диапазоном [begin;end)
    *
    * Более подробно поговом об итераторах, когда будем проходить STL
    \******************************************************************************************/

    // Вот так обходится вектор при помощи итератора:
    for (auto i = v_2.begin(); i != v_2.end(); ++i)
    {
        std::cout << *i << ' ';
    }

    std::cout << std::endl;

    //Вставим число 1000 перед третьим элемента в v_2:
    v_2.insert(v_2.begin() + 2, 1000);

    for (auto i = v_2.begin(); i != v_2.end(); ++i)
    {
        std::cout << *i << ' ';
    }

    std::cout << std::endl;

    // Функция-член erase(iterator): удаляет элемент, на который указывает итератор iterator.
    // Возвращает итератор на элемент, следующий после удаленного, или end, если удален последний элемент.
    // Удалим 3-й элемент из v_2:
    v_2.erase(v_2.begin() + 3);

    for (auto i = v_2.begin(); i != v_2.end(); ++i)
    {
        std::cout << *i << ' ';
    }

    std::cout << std::endl;

    // Можем вырезать целый диапазон элементов. Вот так, например, удалятся все элементы v_2, кроме первого и последнего:
    v_2.erase(v_2.begin() + 1, v_2.end() - 1);

    for (auto i = v_2.begin(); i != v_2.end(); ++i)
    {
        std::cout << *i << ' ';
    }

    std::cout << std::endl;

    return EXIT_SUCCESS;
}
